// 数据结构
// 产生式：每个终结符和非终结符用string表示，增强泛化能力；
//        一个非终结符可对应多个产生式
// 例如：存在产生式 id -> Expr id Type | D : Type
// 即可用以下方式存储: (VN, 产生式右部id) -> List<stirng>
map<string, int> production

// first和follow集
set first, follow

// 预测分析表:(VN,VT) -> 产生式右部
map<string,string> predictTable

// 获取每个符号对应的first集合
// first[V]表示符号V的first集合
set getFirstByChar(char V) { 
    if (status[V] == true) return first[V] // first[V]已找完，直接返回（剪枝）
    for (beta in product[V] { // beta是V的产生式右部
        set = getFirstByString(beta)
        first[V].insert(set)
    }
    status[V] = true // 表示First[V]求解完毕
    return first[V]
}
// 根据产生式（字符串）得到相应的First集合
// 便于构造FOLLOW集合预测分析表时直接调用
// beta：产生式右部； retSet：保存要返回的集合（即beta对应的first）
set getFirstByString(string beta) { 
        if (beta[0] == epislon) { // 产生式第一个符号为空串
            retSet.insert(epislon)
        }
        else if (beta[0] == VT) { // 产生式第一个符号为终结符VT
            retSet.insert(beta[0])
        }
        else { // 产生式第一个符号为非终结符VN
            tset = getFirstByChar(beta[0])
            if (tset.has(epislon)) { // first集包含空串
                retSet.insert(tset-epislon) // 去除空串后加入集合
                if (beta.length == 1) retSet.insert(epislon) // 所有非终结符均可推出空串
                else retSet.insert(getFirstByString(beta[1..n-1])) // 对剩余产生式递归求解
            }
            else retSet.insert(tset) // first不含空串
        }
        return retSet
}
// 创建每个非终结符的first集
void createFirstSet() {
    status均初始化为false
    for (VN in VNSet) { // 遍历每个非终结符
        // first[VN]尚未求解完成，继续求解，dfs思想
        if (!status[VN]) getFirstByChar(VN)
    }
}

//====================================================================
// 获取每个符号对应的follow集合
// follow[V]表示符号V的follow集合
set getFollowByChar(char VN) {
    if (status[VN] == true) return follow[VN]  // follow[V]已找完，直接返回（剪枝）
    for (beta in 所有候选式) { // 遍历所有候选式（即所有产生式右部）
        if (beta.has(VN)) { // 候选式包含非终结符VN
            idx = VN在beta中的位置
            if (VN 是最后一个符号 && VN != VN1) {
                retSet.insert(getFollowByChar(VN1)) // VN1是产生式的左侧非终结符,将其follow加入VN
            }
            else if (beta[idx+1] == VT) { // 非终结符后面紧跟终结符
                retSet.insert(beta[idx+1])
            }
            else if(beta[idx+1] == VN) { // 非终结符后面紧跟非终结符
                tset = getFirstByString(beta[idx+1...n-1]) // 获取VN后面子串对应的first集合
                retSet.insert(tset - epislon)
                if (tset.has(epislon) && VN != VN1) { // VN可推出空
                    retSet.insert(getFollowByChar(VN1)) // VN1是产生式的左侧非终结符
                }
            }
        }
    }
    status[VN] = true
    return retSet
}

// 创建每个非终结符的Follow集
void createFollowSet() {
    follow[S].insert('#') // 初始化，在文法开始符的Follow加上‘#’
    status均初始化为false
    for (VN in VNSet) { // 遍历每个非终结符
        // follow[VN]尚未求解完成，继续求解，dfs思想
        if (!status[VN]) follow[VN].insert(getFollowByChar(VN))
    }
}